# ProposerVM Design

Snowman++ is a congestion control mechanism that can be activated for a snowman VM by wrapping the existing VM with a `proposerVM` one upon creation. An activation time needs to be specified, following which the congestion control mechanism will be enforced.

## Block Structure

Generally speaking a `proposerVM` wraps an inner block generated by the inner VM into a `proposervm.Block`. Once the activation time has past, the `proposervm.Block` will attach a header to inner block, carrying all the fields necessary to implement the congestion mechanism. No changes are performed on the inner block, but the inclusion of the header does change the block ID and the serialized version of the block.

There are three kinds of `proposervm.Blocks`:

- `preForkBlock` is a simple wrapper of an inner block. A `preForkBlock` does not change the ID or serialization of an inner block; it's simply an in-memory object allowing correct verification of `preForkBlocks` (see Transition Handling section for further details of why this is required).
- `postForkBlock` adds congestion-control related fields to an inner block, resulting in a different ID and serialization than the inner block. Note that for such blocks, serialization is a two step process: the header is serialized at the `proposerVM` level, while the inner block serialization is deferred to the inner VM.
- `postForkOption` wraps inner blocks that are associated with an Oracle Block. This enables oracle blocks to be issued without enforcing the congestion control mechanism. Similarly to `postForkBlocks`, this changes the block's ID and serialization.

The following invariant holds:

- Given a `proposervm.Block` **C** and its parent block **P**, **P**'s inner block must be **C**'s inner block's parent.
- Only one verification attempt will be issued to a *valid* inner block. On the contrary multiple verification calls can be issued to invalid inner blocks.
- Rejection of a `proposervm.Block` does not entail rejection of inner block it wraps. This is due to multiple `proposervm.Blocks` being able to wrap the same inner block. Without proper handling this could result in an inner block being accepted after being rejected. Therefore, an inner block is only rejected when a sibling block is being accepted.

## Execution modes

When creating a `proposerVM`, one must specify an activation time following which the congestion control mechanism will be enforced. Therefore, the `proposerVM` must be able to execute before the mechanism is enforced, after the mechanism is enforced, and during the enabling of the mechanism.

### Pre-fork Execution

Before the congestion control mechanism is enforced, it must hold that the chain's rules are unchanged.

- `preForkBlocks` are the only blocks that are able to be verified successfully.

### Post-fork Execution

After the congestion control mechanism is enforced, it must hold that the inner VM's rules are still enforced, and that blocks will only be verified if they are signed by the correct validator.

- If an inner block's `Verify` is called, then it is enforced that the `proposervm.Blocks` additional verification must have already passed. This maintains the invariant that when `Verify` passes, either `Accept` or `Reject` will eventually be called on the block.
- Given a parent block, there must be one deterministic proposer window for every child block. This ensures that modifying the child block doesn't allow conflicting proposal windows.
- The proposal windows should rotate after each block, to avoid a single proposer from dominating the block production.
- `postForkBlocks` are issued only when the local node's ID is currently in their proposal window.
- `postForkOptions` are only allowed after a `postForkBlock` that implements `Options` and do not require signatures.

### Fork Transition Execution

- Each `proposervm.Block` whose timestamp follows the activation time, must have its children made up of `postForkBlocks` or `postForkOptions`.
