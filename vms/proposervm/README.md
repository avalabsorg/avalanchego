# Notes on ProposerVM Design

## ProposerVM

Snowman++ congestion control mechanism can be activated for each snowman-like VM by wrapping the VM into a proposerVM one upon creation. An activation time needs to be specified, following which the congestion control mechanism will kick in.

## Block Structure

Generally speaking a proposer VM wraps inner blocks generated by inner VM into a proposer VM block.
Once the fork is activated, the proposer VM block will prepend a header to inner block, carrying all the fields necessary to implement the congestion mechanism.  No changes are performed on the inner block, but the inclusion of the header does change the block ID and the serialized version of the block.
Technically there are three kinds of proposer VM.blocks:

* preForkBlock is a simple wrap of an inner block. preForkBlock does not change ID or serialization of inner block; it's simply an in-memory object allowing ad-hoc verification of pre fork blocks (see Fork Handling section for further details of why this is necessary)
* postForkBlock adds congestion-control-related fields to inner blocks, resulting in a different ID and serialization of the inner block. Note that for such blocks, serialization is a two step process: the header is serialized at proposervm level, while inner block serialization is deferred to the inner VM.
* postForkOption wraps inner Options Blocks associated with an Oracle Block.  

The following invariant holds:

* Given a proposervm.Block C and its parent block P, P's inner block is C's inner block's parent.
* Multiple proposervm.Blocks can wrap the same inner block. However upon proposervm.Blocks verification, only once call will be issued to a *valid inner block* verification. On the contrary multiple verification calls can be issued to an invalid inner block.
* Rejection of a proposervm.Block does not entail rejection of inner block it wraps. A inner block will be rejected only when a sibling will be accepted.

## Fork Handling

Upon ProposerVM creation you need to specify an activation time following which blocks generated by the inner VM will be wrapped into proposer block and the congestion control mechanism will kick in. Technically the fork process is handled as follows:

* All the blocks generated by a ProposerVM are of type proposerVM.ProposerBlock, whether they come before or after the fork. The proposerVM.ProposerBlock blocks implement the snowman.Block interface, hence they can be smoothly processed by the engine. Post-fork proposer blocks have the inner block decorated with a header, while pre-fork proposer blocks serialize exactly as the inner blocks do and have the same block ID. The proposerVM.ProposerBlock allow to extend verification of inner blocks and handle, among other things, forks.
* The following rule is enforced: each proposerBlock, pre-fork or post-fork, whose timestamp follows activation time, must have its progeny made up of post-fork only blocks. The rule is enforced in ProposerBlock.Verify() call.
* As soon as a pre-fork block is accepted whose timestamp follows activation time, pre-fork blocks won't be verify anymore
